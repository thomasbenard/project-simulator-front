<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata"></script>
    <script src="https://bossanova.uk/jspreadsheet/v4/jexcel.js"></script>
    <script src="https://jsuites.net/v4/jsuites.js"></script>
    <link rel="stylesheet" href="https://bossanova.uk/jspreadsheet/v4/jexcel.css" type="text/css" />
    <link rel="stylesheet" href="https://jsuites.net/v4/jsuites.css" type="text/css" />
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .description {
            color: #666;
            margin-bottom: 30px;
        }
        .input-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        input[type="number"], select {
            width: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #2980b9;
        }
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        .results {
            margin-top: 30px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        .results.visible {
            display: block;
        }
        .results h2 {
            margin-top: 0;
            color: #2c3e50;
        }
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
        }
        .stat-card .label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }
        .stat-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        .stat-card .percent {
            font-size: 14px;
            color: #e74c3c;
        }
        .progress {
            margin-top: 20px;
            display: none;
        }
        .progress.visible {
            display: block;
        }
        .progress-bar {
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #3498db;
            transition: width 0.1s;
        }
        .help-text {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .distribution-info {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .chart-container {
            margin-top: 30px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        .chart-container.visible {
            display: block;
        }
        .chart-container h2 {
            margin-top: 0;
            color: #2c3e50;
        }
        .distribution-editor {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 20px;
            align-items: start;
        }
        .spreadsheet-wrapper {
            background: white;
            border-radius: 4px;
            overflow: hidden;
            width: fit-content;
        }
        .spreadsheet-wrapper .jexcel_content {
            max-height: 350px;
        }
        .jexcel_container {
            width: auto !important;
        }
        .distribution-chart-wrapper {
            background: white;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #ddd;
            min-height: 300px;
        }
        .chart-help {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
            text-align: center;
        }
        @media (max-width: 700px) {
            .distribution-editor {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>Project Simulator</h1>
    <p class="description">
        Monte Carlo simulation to estimate actual project duration based on probability distributions.
        Simulates how task estimates vary from actual completion times.
    </p>

    <div class="input-group">
        <label for="numberOfTasks">Number of Tasks</label>
        <input type="number" id="numberOfTasks" value="1000" min="1" max="100000">
        <p class="help-text">Number of tasks to simulate</p>
    </div>

    <div class="input-group">
        <label for="taskSizePreset">Task Size Distribution</label>
        <select id="taskSizePreset">
            <option value="uniform">Uniform (all size 1)</option>
            <option value="fibonacci">Fibonacci (1, 2, 3, 5, 8, 13)</option>
            <option value="custom">Custom</option>
        </select>
        <div id="taskSizeInfo" class="distribution-info"></div>
    </div>

    <div class="input-group">
        <label>Task Size Data</label>
        <div class="distribution-editor">
            <div class="spreadsheet-wrapper">
                <div id="taskSizeSpreadsheet"></div>
            </div>
            <div class="distribution-chart-wrapper">
                <canvas id="taskSizeChart"></canvas>
                <p class="chart-help">Drag bars to adjust weights</p>
            </div>
        </div>
    </div>

    <div class="input-group">
        <label for="numberOfRuns">Number of Simulation Runs</label>
        <input type="number" id="numberOfRuns" value="100" min="1" max="10000">
        <p class="help-text">More runs = more accurate statistics</p>
    </div>

    <div class="input-group">
        <label for="rejectionRate">Rejection Rate (%)</label>
        <input type="number" id="rejectionRate" value="0" min="0" max="99" step="1">
        <p class="help-text">Probability that a completed task is rejected and must be redone (0-99%)</p>
    </div>

    <div class="input-group">
        <label for="numberOfProgrammers">Number of Programmers</label>
        <input type="number" id="numberOfProgrammers" value="1" min="1" max="100">
        <p class="help-text">Team size - tasks are parallelized with diminishing returns</p>
    </div>

    <div class="input-group">
        <label for="teamScalingFactor">Team Scaling Factor (α)</label>
        <input type="number" id="teamScalingFactor" value="0.7" min="0.1" max="1.0" step="0.1">
        <p class="help-text">Effective capacity = n^α (1.0 = linear, 0.7 = typical, 0.5 = high overhead)</p>
    </div>

    <div class="input-group">
        <label for="distributionPreset">Probability Distribution</label>
        <select id="distributionPreset">
            <option value="default">Default (Sharp peak, long tail)</option>
            <option value="flatter">Flatter (Wider peak)</option>
            <option value="shortTail">Short Tail (No extreme outliers)</option>
            <option value="custom">Custom</option>
        </select>
        <div id="distributionInfo" class="distribution-info"></div>
    </div>

    <div class="input-group">
        <label>Distribution Data</label>
        <div class="distribution-editor">
            <div class="spreadsheet-wrapper">
                <div id="distributionSpreadsheet"></div>
            </div>
            <div class="distribution-chart-wrapper">
                <canvas id="distributionChart"></canvas>
                <p class="chart-help">Drag bars to adjust weights</p>
            </div>
        </div>
    </div>

    <button id="runBtn">Run Simulation</button>

    <div class="progress" id="progress">
        <p>Running simulation... <span id="progressText">0%</span></p>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
    </div>

    <div class="results" id="results">
        <h2>Results</h2>
        <div class="stat-grid">
            <div class="stat-card">
                <div class="label">Naive Base Estimate</div>
                <div class="value" id="naiveEstimate">-</div>
                <div class="percent" id="naiveEstimateInfo"></div>
            </div>
            <div class="stat-card">
                <div class="label">Adjusted Base Estimate</div>
                <div class="value" id="adjustedEstimate">-</div>
                <div class="percent" id="adjustedEstimateInfo"></div>
            </div>
            <div class="stat-card">
                <div class="label">Effective Team Capacity</div>
                <div class="value" id="effectiveCapacity">-</div>
                <div class="percent" id="capacityPercent"></div>
            </div>
            <div class="stat-card">
                <div class="label">Average Duration</div>
                <div class="value" id="avgDuration">-</div>
                <div class="percent" id="avgPercent"></div>
            </div>
            <div class="stat-card">
                <div class="label">Median Duration</div>
                <div class="value" id="medianDuration">-</div>
                <div class="percent" id="medianPercent"></div>
            </div>
            <div class="stat-card">
                <div class="label">Standard Deviation</div>
                <div class="value" id="stdDev">-</div>
                <div class="percent" id="stdDevPercent"></div>
            </div>
            <div class="stat-card">
                <div class="label">Min Duration</div>
                <div class="value" id="minDuration">-</div>
                <div class="percent" id="minPercent"></div>
            </div>
            <div class="stat-card">
                <div class="label">Max Duration</div>
                <div class="value" id="maxDuration">-</div>
                <div class="percent" id="maxPercent"></div>
            </div>
        </div>
    </div>

    <div class="chart-container" id="chartContainer">
        <h2>Simulation Results Distribution</h2>
        <canvas id="resultsChart"></canvas>
    </div>

    <script>
        // Task size distributions
        const TASK_SIZE_DISTRIBUTIONS = {
            uniform: [
                [1, 100]
            ],
            fibonacci: [
                [1, 40], [2, 25], [3, 18], [5, 10], [8, 5], [13, 2]
            ]
        };

        const TASK_SIZE_INFO = {
            uniform: 'All tasks have the same estimated size (1 unit). This is the default behavior.',
            fibonacci: 'Task sizes follow Fibonacci sequence (1, 2, 3, 5, 8, 13) with more small tasks than large ones.',
            custom: 'Enter your own task size distribution below.'
        };

        // Preset distributions (converted from CSV files)
        const DISTRIBUTIONS = {
            default: [
                [0, 0], [10, 0.1], [20, 0.1], [30, 0.2], [40, 0.2], [50, 0.3], [60, 0.5], [70, 1],
                [80, 2.5], [90, 5], [100, 30], [110, 28], [120, 25], [130, 20], [140, 15], [150, 10],
                [160, 5], [170, 3], [180, 2], [190, 1.5], [200, 1], [210, 1], [220, 1], [230, 1],
                [240, 1], [250, 1], [260, 1], [270, 1], [280, 1], [290, 1], [300, 1],
                [310, 0.9], [320, 0.9], [330, 0.9], [340, 0.9], [350, 0.9], [360, 0.9], [370, 0.9], [380, 0.9], [390, 0.9], [400, 0.9],
                [410, 0.8], [420, 0.8], [430, 0.8], [440, 0.8], [450, 0.8], [460, 0.8], [470, 0.8], [480, 0.8], [490, 0.8], [500, 0.8],
                [510, 0.7], [520, 0.7], [530, 0.7], [540, 0.7], [550, 0.7], [560, 0.7], [570, 0.7], [580, 0.7], [590, 0.7], [600, 0.7],
                [610, 0.6], [620, 0.6], [630, 0.6], [640, 0.6], [650, 0.6], [660, 0.6], [670, 0.6], [680, 0.6], [690, 0.6],
                [700, 0.5], [710, 0.5], [720, 0.5], [730, 0.5], [740, 0.5], [750, 0.5], [760, 0.5], [770, 0.5], [780, 0.5], [790, 0.5],
                [800, 0.5], [810, 0.5], [820, 0.5], [830, 0.5], [840, 0.5], [850, 0.5], [860, 0.5], [870, 0.5], [880, 0.5], [890, 0.5],
                [900, 0.5], [910, 0.5], [920, 0.5], [930, 0.5], [940, 0.5], [950, 0.5], [960, 0.5], [970, 0.5], [980, 0.5], [990, 0.5], [1000, 0.5]
            ],
            flatter: [
                [0, 0], [10, 0.1], [20, 0.2], [30, 0.4], [40, 0.8], [50, 1.5], [60, 3], [70, 5],
                [80, 8], [90, 12], [100, 15], [110, 14.5], [120, 14.5], [130, 14], [140, 12], [150, 10],
                [160, 8], [170, 6], [180, 4], [190, 3], [200, 2.5], [210, 2], [220, 1.8], [230, 1.6],
                [240, 1.4], [250, 1.2], [260, 1], [270, 1], [280, 1], [290, 1], [300, 1],
                [310, 0.9], [320, 0.9], [330, 0.9], [340, 0.9], [350, 0.9], [360, 0.9], [370, 0.9], [380, 0.9], [390, 0.9], [400, 0.9],
                [410, 0.8], [420, 0.8], [430, 0.8], [440, 0.8], [450, 0.8], [460, 0.8], [470, 0.8], [480, 0.8], [490, 0.8], [500, 0.8],
                [510, 0.7], [520, 0.7], [530, 0.7], [540, 0.7], [550, 0.7], [560, 0.7], [570, 0.7], [580, 0.7], [590, 0.7], [600, 0.7],
                [610, 0.6], [620, 0.6], [630, 0.6], [640, 0.6], [650, 0.6], [660, 0.6], [670, 0.6], [680, 0.6], [690, 0.6],
                [700, 0.5], [710, 0.5], [720, 0.5], [730, 0.5], [740, 0.5], [750, 0.5], [760, 0.5], [770, 0.5], [780, 0.5], [790, 0.5],
                [800, 0.5], [810, 0.5], [820, 0.5], [830, 0.5], [840, 0.5], [850, 0.5], [860, 0.5], [870, 0.5], [880, 0.5], [890, 0.5],
                [900, 0.5], [910, 0.5], [920, 0.5], [930, 0.5], [940, 0.5], [950, 0.5], [960, 0.5], [970, 0.5], [980, 0.5], [990, 0.5], [1000, 0.5]
            ],
            shortTail: [
                [0, 0], [10, 0.1], [20, 0.1], [30, 0.2], [40, 0.2], [50, 0.3], [60, 0.5], [70, 1],
                [80, 2.5], [90, 5], [100, 30], [110, 28], [120, 25], [130, 20], [140, 15], [150, 10],
                [160, 5], [170, 3], [180, 2], [190, 1.5], [200, 1], [210, 0.8], [220, 0.6], [230, 0.4],
                [240, 0.3], [250, 0.2], [260, 0.15], [270, 0.1], [280, 0.05], [290, 0.02], [300, 0]
            ]
        };

        const DISTRIBUTION_INFO = {
            default: 'Sharp peak at 100% with a long tail extending to 1000%. Models projects with occasional extreme delays.',
            flatter: 'Broader, flatter peak across 100-130%. Represents more uniform variation around estimates.',
            shortTail: 'Same peak as default but cuts off at 300%. Models projects without extreme outliers.',
            custom: 'Enter your own probability distribution below.'
        };

        // DOM elements
        const numberOfTasksInput = document.getElementById('numberOfTasks');
        const numberOfRunsInput = document.getElementById('numberOfRuns');
        const rejectionRateInput = document.getElementById('rejectionRate');
        const numberOfProgrammersInput = document.getElementById('numberOfProgrammers');
        const teamScalingFactorInput = document.getElementById('teamScalingFactor');
        const distributionPresetSelect = document.getElementById('distributionPreset');
        const distributionInfo = document.getElementById('distributionInfo');
        const taskSizePresetSelect = document.getElementById('taskSizePreset');
        const taskSizeInfo = document.getElementById('taskSizeInfo');
        const runBtn = document.getElementById('runBtn');
        const progressDiv = document.getElementById('progress');
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const resultsDiv = document.getElementById('results');
        const chartContainer = document.getElementById('chartContainer');
        const resultsChartCanvas = document.getElementById('resultsChart');
        const distributionChartCanvas = document.getElementById('distributionChart');
        const taskSizeChartCanvas = document.getElementById('taskSizeChart');
        let resultsChart = null;
        let distributionChart = null;
        let taskSizeChart = null;
        let spreadsheet = null;
        let taskSizeSpreadsheet = null;

        // Current distribution data
        let currentDistribution = [];
        let currentTaskSizeDistribution = [];
        let isUpdatingFromChart = false;
        let isUpdatingTaskSizeFromChart = false;

        // Get distribution from spreadsheet
        function getDistributionFromSpreadsheet() {
            if (!spreadsheet) return [];
            const data = spreadsheet.getData();
            const distribution = [];

            data.forEach(row => {
                const percentage = parseFloat(row[0]);
                const weight = parseFloat(row[1]);

                if (!isNaN(percentage) && !isNaN(weight)) {
                    distribution.push({ percentage, weight });
                }
            });

            return distribution.sort((a, b) => a.percentage - b.percentage);
        }

        // Update spreadsheet from distribution data
        function updateSpreadsheet(distribution) {
            if (!spreadsheet) return;
            const data = distribution.map(d => [d.percentage, d.weight]);
            spreadsheet.setData(data);
        }

        // Handle spreadsheet changes
        function onSpreadsheetChange() {
            if (isUpdatingFromChart) return;
            currentDistribution = getDistributionFromSpreadsheet();
            renderDistributionChart(false);
        }

        // Initialize spreadsheet
        function initSpreadsheet(data) {
            const container = document.getElementById('distributionSpreadsheet');
            container.innerHTML = '';

            spreadsheet = jspreadsheet(container, {
                data: data.map(d => [d.percentage, d.weight]),
                columns: [
                    { type: 'numeric', title: '% of Estimate', width: 120 },
                    { type: 'numeric', title: 'Weight', width: 100 }
                ],
                minDimensions: [2, 1],
                allowInsertRow: true,
                allowDeleteRow: true,
                allowInsertColumn: false,
                allowDeleteColumn: false,
                columnSorting: false,
                tableOverflow: true,
                tableHeight: '350px',
                onchange: onSpreadsheetChange,
                oninsertrow: onSpreadsheetChange,
                ondeleterow: onSpreadsheetChange,
                onundo: onSpreadsheetChange,
                onredo: onSpreadsheetChange
            });
        }

        // Render distribution chart (interactive)
        function renderDistributionChart(updateSpreadsheetData = true) {
            const distribution = currentDistribution.filter(d => d.weight > 0);

            if (distribution.length === 0) {
                if (distributionChart) {
                    distributionChart.destroy();
                    distributionChart = null;
                }
                return;
            }

            const labels = distribution.map(d => `${d.percentage}%`);
            const weights = distribution.map(d => d.weight);

            if (distributionChart) {
                distributionChart.destroy();
            }

            distributionChart = new Chart(distributionChartCanvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Weight',
                        data: weights,
                        backgroundColor: 'rgba(46, 204, 113, 0.7)',
                        borderColor: 'rgba(46, 204, 113, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Probability Distribution'
                        },
                        legend: {
                            display: false
                        },
                        dragData: {
                            round: 1,
                            showTooltip: true,
                            onDragEnd: function(e, datasetIndex, index, value) {
                                // Update the distribution data
                                const visibleDist = currentDistribution.filter(d => d.weight > 0);
                                const percentage = visibleDist[index].percentage;

                                // Find and update in main distribution
                                const mainIndex = currentDistribution.findIndex(d => d.percentage === percentage);
                                if (mainIndex !== -1) {
                                    currentDistribution[mainIndex].weight = Math.max(0, value);
                                    isUpdatingFromChart = true;
                                    updateSpreadsheet(currentDistribution);
                                    isUpdatingFromChart = false;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '% of Estimate'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 20
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Weight'
                            },
                            beginAtZero: true,
                            min: 0
                        }
                    }
                }
            });
        }

        // Load distribution from preset array
        function loadDistribution(dist) {
            currentDistribution = dist
                .filter(([_, w]) => w >= 0)
                .map(([p, w]) => ({ percentage: p, weight: w }));
            initSpreadsheet(currentDistribution);
            renderDistributionChart(false);
        }

        // ===== Task Size Distribution Functions =====

        // Get task size distribution from spreadsheet
        function getTaskSizeFromSpreadsheet() {
            if (!taskSizeSpreadsheet) return [];
            const data = taskSizeSpreadsheet.getData();
            const distribution = [];

            data.forEach(row => {
                const size = parseFloat(row[0]);
                const weight = parseFloat(row[1]);

                if (!isNaN(size) && !isNaN(weight) && size > 0) {
                    distribution.push({ size, weight });
                }
            });

            return distribution.sort((a, b) => a.size - b.size);
        }

        // Update task size spreadsheet from distribution data
        function updateTaskSizeSpreadsheet(distribution) {
            if (!taskSizeSpreadsheet) return;
            const data = distribution.map(d => [d.size, d.weight]);
            taskSizeSpreadsheet.setData(data);
        }

        // Handle task size spreadsheet changes
        function onTaskSizeSpreadsheetChange() {
            if (isUpdatingTaskSizeFromChart) return;
            currentTaskSizeDistribution = getTaskSizeFromSpreadsheet();
            renderTaskSizeChart(false);
        }

        // Initialize task size spreadsheet
        function initTaskSizeSpreadsheet(data) {
            const container = document.getElementById('taskSizeSpreadsheet');
            container.innerHTML = '';

            taskSizeSpreadsheet = jspreadsheet(container, {
                data: data.map(d => [d.size, d.weight]),
                columns: [
                    { type: 'numeric', title: 'Task Size', width: 100 },
                    { type: 'numeric', title: 'Weight', width: 100 }
                ],
                minDimensions: [2, 1],
                allowInsertRow: true,
                allowDeleteRow: true,
                allowInsertColumn: false,
                allowDeleteColumn: false,
                columnSorting: false,
                tableOverflow: true,
                tableHeight: '200px',
                onchange: onTaskSizeSpreadsheetChange,
                oninsertrow: onTaskSizeSpreadsheetChange,
                ondeleterow: onTaskSizeSpreadsheetChange,
                onundo: onTaskSizeSpreadsheetChange,
                onredo: onTaskSizeSpreadsheetChange
            });
        }

        // Render task size chart (interactive)
        function renderTaskSizeChart(updateSpreadsheetData = true) {
            const distribution = currentTaskSizeDistribution.filter(d => d.weight > 0);

            if (distribution.length === 0) {
                if (taskSizeChart) {
                    taskSizeChart.destroy();
                    taskSizeChart = null;
                }
                return;
            }

            const labels = distribution.map(d => `${d.size}`);
            const weights = distribution.map(d => d.weight);

            if (taskSizeChart) {
                taskSizeChart.destroy();
            }

            taskSizeChart = new Chart(taskSizeChartCanvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Weight',
                        data: weights,
                        backgroundColor: 'rgba(155, 89, 182, 0.7)',
                        borderColor: 'rgba(155, 89, 182, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Task Size Distribution'
                        },
                        legend: {
                            display: false
                        },
                        dragData: {
                            round: 1,
                            showTooltip: true,
                            onDragEnd: function(e, datasetIndex, index, value) {
                                const visibleDist = currentTaskSizeDistribution.filter(d => d.weight > 0);
                                const size = visibleDist[index].size;

                                const mainIndex = currentTaskSizeDistribution.findIndex(d => d.size === size);
                                if (mainIndex !== -1) {
                                    currentTaskSizeDistribution[mainIndex].weight = Math.max(0, value);
                                    isUpdatingTaskSizeFromChart = true;
                                    updateTaskSizeSpreadsheet(currentTaskSizeDistribution);
                                    isUpdatingTaskSizeFromChart = false;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Task Size (units)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Weight'
                            },
                            beginAtZero: true,
                            min: 0
                        }
                    }
                }
            });
        }

        // Load task size distribution from preset array
        function loadTaskSizeDistribution(dist) {
            currentTaskSizeDistribution = dist
                .filter(([_, w]) => w >= 0)
                .map(([s, w]) => ({ size: s, weight: w }));
            initTaskSizeSpreadsheet(currentTaskSizeDistribution);
            renderTaskSizeChart(false);
        }

        // Update when task size preset changes
        taskSizePresetSelect.addEventListener('change', () => {
            const preset = taskSizePresetSelect.value;
            taskSizeInfo.textContent = TASK_SIZE_INFO[preset];

            if (preset !== 'custom' && TASK_SIZE_DISTRIBUTIONS[preset]) {
                loadTaskSizeDistribution(TASK_SIZE_DISTRIBUTIONS[preset]);
            }
        });

        // Initialize task size distribution with default
        taskSizePresetSelect.dispatchEvent(new Event('change'));

        // Update when preset changes
        distributionPresetSelect.addEventListener('change', () => {
            const preset = distributionPresetSelect.value;
            distributionInfo.textContent = DISTRIBUTION_INFO[preset];

            if (preset !== 'custom' && DISTRIBUTIONS[preset]) {
                loadDistribution(DISTRIBUTIONS[preset]);
            }
        });

        // Initialize with default distribution
        distributionPresetSelect.dispatchEvent(new Event('change'));

        // Simulation class
        class ProjectSimulator {
            constructor(distribution, taskSizeDistribution) {
                this.distribution = distribution;
                this.totalWeight = distribution.reduce((sum, entry) => sum + entry.weight, 0);
                this.taskSizeDistribution = taskSizeDistribution;
                this.totalTaskSizeWeight = taskSizeDistribution.reduce((sum, entry) => sum + entry.weight, 0);
            }

            selectWeightedPercentage() {
                const randomValue = Math.random() * this.totalWeight;
                let cumulativeWeight = 0;

                for (const entry of this.distribution) {
                    cumulativeWeight += entry.weight;
                    if (randomValue <= cumulativeWeight) {
                        return entry.percentage;
                    }
                }

                return this.distribution[this.distribution.length - 1].percentage;
            }

            selectTaskSize() {
                const randomValue = Math.random() * this.totalTaskSizeWeight;
                let cumulativeWeight = 0;

                for (const entry of this.taskSizeDistribution) {
                    cumulativeWeight += entry.weight;
                    if (randomValue <= cumulativeWeight) {
                        return entry.size;
                    }
                }

                return this.taskSizeDistribution[this.taskSizeDistribution.length - 1].size;
            }

            simulate(numberOfTasks, rejectionRate = 0) {
                let totalDuration = 0;

                for (let i = 0; i < numberOfTasks; i++) {
                    // Select task size from distribution
                    const taskSize = this.selectTaskSize();

                    // Complete the task (may need multiple attempts if rejected)
                    let accepted = false;
                    while (!accepted) {
                        const percentage = this.selectWeightedPercentage();
                        totalDuration += taskSize * (percentage / 100);

                        // Check if task is rejected and needs to be redone
                        if (rejectionRate > 0 && Math.random() * 100 < rejectionRate) {
                            // Task rejected, loop continues to redo
                        } else {
                            accepted = true;
                        }
                    }
                }

                return totalDuration;
            }
        }

        // Statistics functions
        function calculateAverage(values) {
            return values.reduce((sum, v) => sum + v, 0) / values.length;
        }

        function calculateMedian(values) {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);

            if (sorted.length % 2 === 0) {
                return (sorted[mid - 1] + sorted[mid]) / 2;
            }
            return sorted[mid];
        }

        function calculateStandardDeviation(values) {
            const avg = calculateAverage(values);
            const squareDiffs = values.map(v => Math.pow(v - avg, 2));
            return Math.sqrt(calculateAverage(squareDiffs));
        }

        // Create histogram data from results
        function createHistogram(values, numBins = 30) {
            const min = Math.min(...values);
            const max = Math.max(...values);
            const binWidth = (max - min) / numBins;

            const bins = [];
            const labels = [];

            for (let i = 0; i < numBins; i++) {
                bins.push(0);
                const binStart = min + i * binWidth;
                const binEnd = min + (i + 1) * binWidth;
                labels.push(`${binStart.toFixed(0)}-${binEnd.toFixed(0)}`);
            }

            for (const value of values) {
                let binIndex = Math.floor((value - min) / binWidth);
                if (binIndex >= numBins) binIndex = numBins - 1;
                if (binIndex < 0) binIndex = 0;
                bins[binIndex]++;
            }

            return { bins, labels };
        }

        // Render results chart
        function renderChart(results, baseEstimate) {
            const { bins, labels } = createHistogram(results);

            if (resultsChart) {
                resultsChart.destroy();
            }

            resultsChart = new Chart(resultsChartCanvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Simulations',
                        data: bins,
                        backgroundColor: 'rgba(52, 152, 219, 0.7)',
                        borderColor: 'rgba(52, 152, 219, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `Project Duration Distribution (Base Estimate: ${baseEstimate})`
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Project Duration (units)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Frequency'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });

            chartContainer.classList.add('visible');
        }

        // Calculate effective team capacity using power law: capacity = n^α
        function calculateEffectiveCapacity(numberOfProgrammers, scalingFactor) {
            return Math.pow(numberOfProgrammers, scalingFactor);
        }

        // Run simulation with progress updates
        async function runSimulation() {
            const numberOfTasks = parseInt(numberOfTasksInput.value);
            const numberOfRuns = parseInt(numberOfRunsInput.value);
            const rejectionRate = parseFloat(rejectionRateInput.value) || 0;
            const numberOfProgrammers = parseInt(numberOfProgrammersInput.value) || 1;
            const teamScalingFactor = parseFloat(teamScalingFactorInput.value) || 0.7;
            const distribution = currentDistribution.filter(d => d.weight > 0);
            const taskSizeDistribution = currentTaskSizeDistribution.filter(d => d.weight > 0);

            if (distribution.length === 0) {
                alert('Please add at least one distribution entry with weight > 0');
                return;
            }

            if (taskSizeDistribution.length === 0) {
                alert('Please add at least one task size entry with weight > 0');
                return;
            }

            runBtn.disabled = true;
            progressDiv.classList.add('visible');
            resultsDiv.classList.remove('visible');
            chartContainer.classList.remove('visible');

            // Calculate effective team capacity
            const effectiveCapacity = calculateEffectiveCapacity(numberOfProgrammers, teamScalingFactor);

            const simulator = new ProjectSimulator(distribution, taskSizeDistribution);
            const results = [];
            const batchSize = Math.max(1, Math.floor(numberOfRuns / 100));

            for (let i = 0; i < numberOfRuns; i++) {
                // Simulate total work, then divide by effective capacity
                const totalWork = simulator.simulate(numberOfTasks, rejectionRate);
                const projectDuration = totalWork / effectiveCapacity;
                results.push(projectDuration);

                // Update progress every batch
                if (i % batchSize === 0 || i === numberOfRuns - 1) {
                    const percent = Math.round(((i + 1) / numberOfRuns) * 100);
                    progressText.textContent = `${percent}%`;
                    progressFill.style.width = `${percent}%`;

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            // Calculate statistics
            const avg = calculateAverage(results);
            const median = calculateMedian(results);
            const stdDev = calculateStandardDeviation(results);
            const min = Math.min(...results);
            const max = Math.max(...results);

            // Calculate average task size from distribution
            const totalTaskSizeWeight = taskSizeDistribution.reduce((sum, d) => sum + d.weight, 0);
            const avgTaskSize = taskSizeDistribution.reduce((sum, d) => sum + d.size * d.weight, 0) / totalTaskSizeWeight;
            const totalEstimatedWork = numberOfTasks * avgTaskSize;

            // Calculate base estimates
            const naiveEstimate = totalEstimatedWork / numberOfProgrammers; // Assumes linear scaling
            const adjustedEstimate = totalEstimatedWork / effectiveCapacity; // Accounts for diminishing returns

            // Display results
            document.getElementById('naiveEstimate').textContent = naiveEstimate.toFixed(2);
            document.getElementById('naiveEstimateInfo').textContent = `${totalEstimatedWork.toFixed(1)} work units / ${numberOfProgrammers} programmers`;
            document.getElementById('adjustedEstimate').textContent = adjustedEstimate.toFixed(2);
            document.getElementById('adjustedEstimateInfo').textContent = `${totalEstimatedWork.toFixed(1)} work units / ${effectiveCapacity.toFixed(2)} effective capacity`;
            document.getElementById('effectiveCapacity').textContent = effectiveCapacity.toFixed(2);
            document.getElementById('capacityPercent').textContent = `${(effectiveCapacity / numberOfProgrammers * 100).toFixed(0)}% efficiency (${numberOfProgrammers} programmers)`;
            document.getElementById('avgDuration').textContent = avg.toFixed(2);
            document.getElementById('avgPercent').textContent = `${(avg / adjustedEstimate * 100).toFixed(1)}% of adjusted | ${(avg / naiveEstimate * 100).toFixed(1)}% of naive`;
            document.getElementById('medianDuration').textContent = median.toFixed(2);
            document.getElementById('medianPercent').textContent = `${(median / adjustedEstimate * 100).toFixed(1)}% of adjusted | ${(median / naiveEstimate * 100).toFixed(1)}% of naive`;
            document.getElementById('stdDev').textContent = stdDev.toFixed(2);
            document.getElementById('stdDevPercent').textContent = `${(stdDev / adjustedEstimate * 100).toFixed(1)}% of adjusted | ${(stdDev / naiveEstimate * 100).toFixed(1)}% of naive`;
            document.getElementById('minDuration').textContent = min.toFixed(2);
            document.getElementById('minPercent').textContent = `${(min / adjustedEstimate * 100).toFixed(1)}% of adjusted | ${(min / naiveEstimate * 100).toFixed(1)}% of naive`;
            document.getElementById('maxDuration').textContent = max.toFixed(2);
            document.getElementById('maxPercent').textContent = `${(max / adjustedEstimate * 100).toFixed(1)}% of adjusted | ${(max / naiveEstimate * 100).toFixed(1)}% of naive`;

            // Render the chart
            renderChart(results, adjustedEstimate);

            progressDiv.classList.remove('visible');
            resultsDiv.classList.add('visible');
            runBtn.disabled = false;
        }

        runBtn.addEventListener('click', runSimulation);
    </script>
</body>
</html>
